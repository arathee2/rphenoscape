---
title: "Mutually Exclusive Phenotypes"
author: "Amandeep Rathee and Hilmar Lapp"
date: "`r format(Sys.Date(), '%B-%d-%Y')`"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rphenoscape)
library(tidyverse)
library(microbenchmark)
```


This vignette showcases two functions `mutual_exclusivity_pair_test` and `mutual_exclusivity_test` both of which are used to compute mutually exclusivity among phenotypes. The `mutual_exclusivity_pair_test` calculates the mutual exclusivity between two phenotypes, and the `mutual_exclusivity_test` calculates the mutual exclusivity for multiple phenotypes.


## 1. Test of mutual exclusivity among two phenotypes.

```{r include=TRUE, eval=TRUE, echo=TRUE, render=FALSE}
mutual_exclusivity_pair <- function(phenotype.a, phenotype.b, studies=NULL, charstates=NULL){
    
    # convert phenotypes to phenotype objects for faster computation
    if (!is.phenotype(phenotype.a)) {
        phenotype.a <- as.phenotype(phenotype.a, withTaxa=TRUE)
    }
    
    if (!is.phenotype(phenotype.b)) {
        phenotype.b <- as.phenotype(phenotype.b, withTaxa=TRUE)
    }
    
    # define mutual exclusivity types
    exclusivity_types <- c('strong_compatibility',
                           'weak_compatibility',
                           'inconclusive_evidence',
                           'weak_exclusivity',
                           'strong_exclusivity')
    is_pair_mutually_exclusive <- exclusivity_types[3]
    
    # load charstates dataframe that contains both the phenotypes
    if (is.null(charstates)) {
        character_states <- charstates(list(phenotype.a, phenotype.b))
    } else {
        character_states <- charstates
    }
    
    # filter the character_states dataframe by studies
    if (!is.null(studies)) {
        character_states <- character_states[character_states$study.id %in% studies, ]
    }
    
    # store the charstate dataframe associated with each phenotype separately for easier computation
    charstates.a <- character_states[(character_states$phenotype.id == phenotype.a$id), ]
    charstates.b <- character_states[(character_states$phenotype.id == phenotype.b$id), ]
    
    # determine mutual exclusivity only if both phenotypes have non-empty states
    num_states.a <- length(charstates.a$state.id)
    num_states.b <- length(charstates.b$state.id)
    if (num_states.a > 0 && num_states.b > 0) {
        
        # compute the intersection of the two characters vectors
        chars.a <- unique(charstates.a$character.id)
        chars.b <- unique(charstates.b$character.id)
        mutual_characters_present <- length(intersect(chars.a, chars.b)) > 0
        
        if (mutual_characters_present) {
            # If the two phenotypes have mutual characters, then
            # there is enough evidence to decide mutual exclusivity among the two phenotypes.
            # Therefore, the mutual exclusion in this case is called 'strong'.
            # Mutual exclusivity is decided by looking at whether the two phenotypes have mutual states.
            
            states.a <- charstates.a$state.id
            states.b <- charstates.b$state.id
            mutual_states_present <- length(intersect(states.a, states.b)) > 0
            
            if (mutual_states_present) {
                # strong compatibility if phenotypes share states
                is_pair_mutually_exclusive <- exclusivity_types[1]
            } else {
                # strong exclusivity if phenotypes do not share states
                is_pair_mutually_exclusive <- exclusivity_types[5]
            }
            
        } else {
            # If there are no mutal characters among the two phenotypes, then
            # there is lack (but not absence) of evidence to determine mutual exclusivity.
            # Therefore, the mutual exclusion in this case is called 'weak'.
            # Mutual exclusivity is decided by looking at whether the two phenotypes have mutual taxa.
            
            mutual_taxa_present <- length(intersect(phenotype.a$taxa$id, phenotype.b$taxa$id)) > 0
            if(mutual_taxa_present){
                # weak compatibility
                is_pair_mutually_exclusive <- exclusivity_types[2]
            } else {
                # weak exclusivity
                is_pair_mutually_exclusive <- exclusivity_types[4]
            }
        }
        
    } else {
        # If either (or both) phenotype(s) have empty state(s), then we say that
        # there is no evidence to compute mutual exclusivity.
        # This block raises a warning and is_pair_mutually_exclusive is returned
        # with the default value: 'inconclusive_evidence'.
        
        if (num_states.a == 0) {
            warning("Phenotype A does not have any states in the charstates dataframe.")
            
        } else if (num_states.b == 0){
            warning("Phenotype B does not have any states in the charstates dataframe.")

        } else {
            warning("Both phenotypes do not have any states in the charstates dataframe.")
        }
    }
    
    # convert mutual exclusivity state to a factor
    is_pair_mutually_exclusive <- factor(is_pair_mutually_exclusive, 
                                         levels = exclusivity_types,
                                         ordered = TRUE)
    # return mutual exclusivity
    is_pair_mutually_exclusive
}
```


```{r include=TRUE, eval=FALSE, echo=TRUE, render=FALSE}
# get phenotypes
phenotypes <- get_phenotypes(entity = "hyomandibular bone", taxon = "Hypancistrus")
phenotypes <- c(phenotypes$id[phenotypes$label == 'hyomandibular bone in contact with prootic bone'],
                phenotypes$id[phenotypes$label == 'hyomandibular bone in contact with quadrate bone'],
                phenotypes$id[phenotypes$label == 'hyomandibular bone position opercle'],
                phenotypes$id[phenotypes$label == 'hyomandibular bone structure metapterygoid'])
# get studies
studies <- pk_get_study_list(entity = "hyomandibular bone", taxon = "Hypancistrus")
study <- studies$id[studies$label == 'Armbruster (2004)']

# check mutual exclusivity
mutual_exclusivity_pair(phenotypes[1], phenotypes[2], studies=study)
```


## 2. Test of mutual exclusivity among more than two phenotypes. 

```{r include=TRUE, eval=TRUE, echo=TRUE, render=FALSE}
mutual_exclusivity <- function(phenotypes, studies=NULL, progress_bar=TRUE){
    
    # make sure that at least two phenotypes are passed
    if (is.null(phenotypes) || length(phenotypes) == 1) {
        stop("Less than two phenotypes passed. The function expects at least two phenotypes to compute mutual exclusivity.")
    }
    
    # initialize a square matrix to store mutual exclusivity result among each pair of phenotypes
    num_phenotypes <- length(phenotypes)
    exclusivity_types <- c('strong_compatibility',
                           'weak_compatibility',
                           'inconclusive_evidence',
                           'weak_exclusivity',
                           'strong_exclusivity')
    mutual_exclusivity_matrix <- matrix(as.integer(factor("inconclusive_evidence",
                                                          levels = exclusivity_types,
                                                          ordered = TRUE)),
                                        nrow=num_phenotypes,
                                        ncol=num_phenotypes)
    rownames(mutual_exclusivity_matrix) <- 1:num_phenotypes
    colnames(mutual_exclusivity_matrix) <- 1:num_phenotypes
    
    # boolean to determine whether resultant dataframe is created or not
    dataframe_created <- FALSE
    
    # initialize variables to keep track of progress of the function
    if (progress_bar) {
        iteration <- 1
        total_iterations <- choose(num_phenotypes, 2) + num_phenotypes
        num_mutual_exclusive_pairs <- 0
        num_mutual_compatible_pairs <- 0
        num_inconclusive_evidence <- 0
    }
    
    # convert phenotypes to phenotype objects for faster computation
    if (!all(sapply(phenotypes, is.phenotype))) {
        phenotypes <- as.phenotype(phenotypes, withTaxa=TRUE)
    }
    
    # load charstates dataframe that contains all the phenotypes
    character_states <- charstates(phenotypes)
    
    # find mutual exclusivity for each pair in the phenotype vector
    for (row in 1:num_phenotypes) {
        for (column in row:num_phenotypes) {
            
            # print progress of the loop
            if (progress_bar == TRUE) {
                cat('\014')
                cat(paste0(round(iteration / (total_iterations) * 100, 4), '% completed\n',
                           'Mutually exclusive pairs  = ', num_mutual_exclusive_pairs, '\n',
                           'Mutually compatible pairs = ', num_mutual_compatible_pairs, '\n',
                           'Inconclusive evidence     = ', num_inconclusive_evidence, '\n'))
                iteration <- iteration + 1
            }
            
            # compute mutual exclusivity among distinct phenotypes only
            if (row != column) {
                
                # compute mutual exclusivity
                mutual_exclusivity <- mutual_exclusivity_pair(phenotypes[[row]],
                                                              phenotypes[[column]],
                                                              studies=studies,
                                                              charstates=character_states)
                # store exclusivity as factor
                #mutual_exclusivity <- factor(mutual_exclusivity,
                #                             levels = exclusivity_types,
                #                             ordered = TRUE)
                
                # store exclusivity result in matrix
                mutual_exclusivity_matrix[row, column] <- as.integer(mutual_exclusivity)
                mutual_exclusivity_matrix[column, row] <- as.integer(mutual_exclusivity)
                
                # store exclusivity result in a dataframe
                dataframe_row <- c(phenotypes[[row]]$id,
                                   phenotypes[[row]]$label,
                                   phenotypes[[column]]$id,
                                   phenotypes[[column]]$label,
                                   as.character(mutual_exclusivity)
                )
                
                # create dataframe
                if (dataframe_created == FALSE) {
                    mutual_exclusivity_df <- data.frame(id.1    = dataframe_row[1],
                                                        label.1 = dataframe_row[2],
                                                        id.2    = dataframe_row[3],
                                                        label.2 = dataframe_row[4],
                                                        mutual_exclusivity = mutual_exclusivity,
                                                        stringsAsFactors = FALSE)
                    dataframe_created <- TRUE
                    
                } else {
                    # append all subsequent results to existing dataframe
                    mutual_exclusivity_df <- rbind(mutual_exclusivity_df, dataframe_row)
                }
                
                # update progress bar statistics
                if (progress_bar) {
                    if (mutual_exclusivity == "strong_exclusivity" || mutual_exclusivity == "weak_exclusivity") {
                        # keep track of the number of exclusive phenotype pairs for printing in the progress bar
                        num_mutual_exclusive_pairs <- num_mutual_exclusive_pairs + 1
                        
                    } else if (mutual_exclusivity == "inconclusive_evidence") {
                        # keep track of the number of phenotype pairs with inconclusive evidence for printing in the progress bar
                        num_inconclusive_evidence <- num_inconclusive_evidence + 1
                        
                    } else if (mutual_exclusivity == "strong_compatibility" || mutual_exclusivity == "weak_compatibility") {
                        # keep track of the number of compatible phenotype pairs for printing in the progress bar
                        num_mutual_compatible_pairs <- num_mutual_compatible_pairs + 1
                    }
                }
                
            } else if (row == column) {
                # a phenotype is strongly compatible with itself
                mutual_exclusivity_matrix[row, column] <- as.integer(factor("strong_compatibility",
                                                                            levels = exclusivity_types,
                                                                            ordered = TRUE))
            }
        }
    }
    
    # change mutual_exclusivity column to factor
    mutual_exclusivity_df$mutual_exclusivity <- factor(mutual_exclusivity_df$mutual_exclusivity,
                                                       levels = exclusivity_types,
                                                       ordered = TRUE)
    
    # return a list containing the resultant matrix and the dataframe
    list(matrix=mutual_exclusivity_matrix,
         dataframe=mutual_exclusivity_df)
}
```


## Find mutual exclusive phenotypes in the Dillman et al. (2016) study

```{r include=TRUE, eval=TRUE, echo=TRUE, render=FALSE}
# get all studies in the database
studies <- pk_get_study_list()
study <- studies$id[studies$label == 'Dillman et al. (2016)']

# get phenotypes
phenotypes <- get_phenotypes(study=study)
phenotypes <- as.phenotype(phenotypes)

# test mutual exclusivity
n <- 7
me <- mutual_exclusivity(phenotypes[1:n], study, progress_bar=FALSE)

# get matrix
me$matrix

# get phenotype pairs
me$dataframe[, c('label.1', 'label.2', 'mutual_exclusivity')]
```

